package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"encoding/json"
	"flashy-cards-kafka-consumer/graph/model"
	producer "flashy-cards-kafka-consumer/kafkaproducer"
	"fmt"
)

// Adds comment to kafka broker
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CommentInput) (*model.Comment, error) {
	//create producer
	prod := producer.NewProducer()

	//convert input into type Comment struct
	comment := model.Comment(input)

	//data, prob := json.Marshal(comment)
	_, prob := json.Marshal(comment)

	if prob != nil {
		return &model.Comment{}, prob
	}

	//for this step...
	//create topic in confluent flash-deck-comment

	// below is code for a connector. Cannot get it to work
	ok := prod.Produce([]byte(comment.ID), []byte(`{"_id":"`+comment.ID+`", "userId":"`+comment.UserID+`", "comment": "`+comment.Comment+`"}`), "flash-deck-comment")

	//ok := prod.Produce([]byte(input.ID), data, "flash-deck-comment") //use a unique id for key! uuid here works

	if ok != nil {
		return &model.Comment{}, ok
	}

	return &comment, nil

}

// GetDeckByUser is the resolver for the getDeckByUser field.
func (r *queryResolver) GetDeckByUser(ctx context.Context, userID string) ([]*model.Deck, error) {
	panic(fmt.Errorf("not implemented: GetDeckByUser - getDeckByUser"))
}

// GetSortedDeck is the resolver for the getSortedDeck field.
func (r *queryResolver) GetSortedDeck(ctx context.Context, options []string) ([]*model.Deck, error) {
	panic(fmt.Errorf("not implemented: GetSortedDeck - getSortedDeck"))
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, email string, password string) (*model.User, error) {
	user := producer.Consume(ctx, r.DB)
	return &user, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
